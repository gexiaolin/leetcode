# 96. 不同的二叉搜索树

+ 题目地址：[leetcode](https://leetcode-cn.com/problems/unique-binary-search-trees/)
+ 题目难度：medium

## 思路

我们可以 `动态规划` 求解。

我们可以遍历有序序列，把第 `i` 个数作为[二叉搜索树](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)的树根，由于二叉搜索树 `左支 < 树根 < 右支` 的特性，可以推断出有序序列的第 `i` 个数作为树根是独特的，所以我们可以存储并复用子问题的解，也就是动态规划法。

在计算当前树根的二叉搜索树数量时，要注意其实左右支的值只和序列数有关，与内容无关。同时在能拿到左右支数量的情况下，通过笛卡尔积来计算可能出现的所有排列组合数。

时间复杂度O(n2)，空间复杂度O(n)。

## 解答

```js
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
    // 我们声明一个数组空间来存储子问题的解
    // 当 n === 0 || n === 1 时，只有唯一解，直接存入我们声明的子问题数组空间
    let map = [1, 1];

    // 0和1的解我们提前存入了，所以从2开始遍历
    for (let i = 2; i <= n; i++) {
        let sum = 0;

        // n === i时，二次遍历，以 j 为树根
        // 则当前树根的二叉树数量应为 `左支数 * 右支数` （笛卡尔积）
        // 由于我们提前定义了map[0]和map[1]，且左右支的数量只和序列数有关
        // 因此可以轻松拿到n === i, j为树根的值，并进行累加
        for (let j = 1; j <= i; j++) {
            sum += map[j - 1] * map[i - j];
        }
        // 将累加后的值存入当前的二叉搜索树数量
        map[i] = sum;
    }

    return map[n];
};
```

## 行能

执行用时 : 56 ms , 在所有 JavaScript 提交中击败了 90.17% 的用户

内存消耗 : 34 MB , 在所有 JavaScript 提交中击败了 68.23% 的用户
